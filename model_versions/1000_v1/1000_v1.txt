def discriminator():
    discriminator_model = tf.keras.models.Sequential(name="discriminator")
    
    discriminator_model.add(tf.keras.layers.Conv2D(64, (3,3), strides=(2, 2), padding='same', input_shape=INPUT_SHAPE))
    discriminator_model.add(tf.keras.layers.LeakyReLU(alpha=0.2))
    
    discriminator_model.add(tf.keras.layers.Conv2D(64, (3,3), strides=(2, 2), padding='same'))
    discriminator_model.add(tf.keras.layers.LeakyReLU(alpha=0.2))
    
    discriminator_model.add(tf.keras.layers.Flatten())
    discriminator_model.add(tf.keras.layers.Dropout(0.5))
    discriminator_model.add(tf.keras.layers.Dense(1, activation='sigmoid'))
    
    discriminator_model.compile(loss='binary_crossentropy', optimizer=tf.keras.optimizers.Adam(lr=0.0002, beta_1=0.5), metrics=['accuracy'])
    return discriminator_model


def generator():
    generator_model = tf.keras.models.Sequential(name="generator")
    
    # Foundation for 8x8 image
    generator_model.add(tf.keras.layers.Dense(128 * 8 * 8, input_dim=LATENT_DIM))
    generator_model.add(tf.keras.layers.LeakyReLU(alpha=0.2))
    generator_model.add(tf.keras.layers.Reshape((8, 8, 128)))

    # Upsample to 16x16
    generator_model.add(tf.keras.layers.Conv2DTranspose(256, (4,4), strides=(2,2), padding='same'))
    generator_model.add(tf.keras.layers.BatchNormalization())
    generator_model.add(tf.keras.layers.LeakyReLU(alpha=0.2))
    
    # Upsample to 32x32
    generator_model.add(tf.keras.layers.Conv2DTranspose(256, (4,4), strides=(2,2), padding='same'))
    generator_model.add(tf.keras.layers.BatchNormalization())
    generator_model.add(tf.keras.layers.LeakyReLU(alpha=0.2))

    generator_model.add(tf.keras.layers.Conv2D(NUM_PIXEL_CHANNELS, (7,7), activation='tanh', padding='same'))

    return generator_model


def gan(generator_model, discriminator_model):
    discriminator_model.trainable = False # freez discirminator
    model = tf.keras.models.Sequential(name="GAN")
    model.add(generator_model)
    model.add(discriminator_model)
    model.compile(loss='binary_crossentropy', optimizer=tf.keras.optimizers.Adam(lr=0.0002, beta_1=0.5))
    return model